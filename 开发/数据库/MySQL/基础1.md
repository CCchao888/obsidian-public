

# 事务



## 事务机制


### 1️⃣ 同一页的数据是不是连续存储的？

- **在同一页 (page, 16KB)** 内，数据是 **物理上紧挨着存放** 的（就像一个小数组一样），所以可以认为它是“连续存储”。
    
- **页之间** 是通过指针连接的，不保证物理连续。
    
- **页内顺序**：
    
    - InnoDB 的表数据按照 **主键顺序** 组织（聚簇索引）。
        
    - 页内的数据项是 **按主键递增排序** 的。
        
    - 如果插入一个新主键值在中间位置，可能会触发 **页分裂**（把一个页拆成两个）。
        

👉 所以，InnoDB 的表数据就是一棵 **B+ 树**，叶子节点页之间是 **有序链表**，而每个页里的行记录也按主键排好序。

---

### 2️⃣ InnoDB 默认事务机制

#### 2.1 autocommit 模式

- InnoDB 默认开启 **事务支持**，并且 **autocommit = ON**。
    
- 这意味着：
    
    - 你随便执行一条 SQL（`INSERT/UPDATE/DELETE`），它就是一个独立事务。
        
    - SQL 执行完成后，InnoDB 会立刻 `COMMIT`。
        

**例子**：

```sql
UPDATE user SET balance = balance - 100 WHERE id = 1;
```

- InnoDB 背后会自动：
    
    1. 开启一个事务
        
    2. 执行更新
        
    3. 写 undo log + redo log
        
    4. 自动提交事务
        

所以你虽然没写 `BEGIN`，但它确实是一个事务。

---

#### 2.2 手动开启事务的场景

- 如果你要保证 **多条 SQL 的原子性**，必须手动控制事务：
    
    ```sql
    BEGIN;
    UPDATE account SET balance = balance - 100 WHERE id = 1;
    UPDATE account SET balance = balance + 100 WHERE id = 2;
    COMMIT;
    ```
    
    如果第二条失败，你可以 `ROLLBACK;`，保证数据一致。
    

---

### 3️⃣ autocommit 带来的问题

- **问题 1：多语句逻辑无法保证原子性**
    
    - 默认 autocommit 下，每条 SQL 都是一个独立事务。
        
    - 如果你要“转账”这种场景（A 扣钱、B 加钱），但只执行了第一条，事务就已经提交了 → 数据不一致。
        
- **问题 2：性能问题**
    
    - 事务提交涉及日志写入 (redo log + binlog)。
        
    - 如果每条 SQL 都是独立事务，日志刷盘频繁，性能会下降。
        
    - 通常在批量操作时会关闭 autocommit，手动控制事务。
        
- **问题 3：锁粒度与持有时间**
    
    - 在 autocommit 下，SQL 结束马上释放锁，别的事务可以立刻进来。
        
    - 在手动事务下，锁会保持到 `COMMIT/ROLLBACK`，隔离性更强。
        

---

✅ **总结**：

- **页内数据是按主键顺序存储的**，连续且有序。
    
- **InnoDB 默认有事务支持**，并且 autocommit 打开 → 每条 SQL 就是一个事务。
    
- **只有涉及多条语句的业务逻辑**，才需要手动开启事务。
    
- **autocommit 有安全性与性能上的局限**，实际项目里经常会手动管理事务。


## 代码实操


### 1️⃣ Java & Spring Boot 事务管理的核心机制

Spring Boot 使用 **Spring Transaction Management** 来管理事务，本质上是通过 **AOP（面向切面编程）+ 数据库驱动的事务 API** 实现的。  
最常见的就是 `@Transactional` 注解。

### `@Transactional` 注解的作用

- 放在 **方法** 或 **类** 上，用来声明这个范围内的数据库操作要在一个事务里完成。
    
- Spring 会自动帮你：
    
    1. **开启事务**
        
    2. 执行方法里的 SQL（通过 MyBatis/JPA/JDBC）
        
    3. 如果没有异常 → `COMMIT`
        
    4. 如果有异常 → `ROLLBACK`
        

**示例**：

```java
@Service
public class AccountService {
    @Autowired
    private AccountMapper accountMapper;

    @Transactional  // 开启事务
    public void transferMoney(Long fromId, Long toId, int amount) {
        accountMapper.decreaseBalance(fromId, amount); // 扣钱
        accountMapper.increaseBalance(toId, amount);   // 加钱
    }
}
```

- 如果 `decreaseBalance` 成功，`increaseBalance` 失败（比如 SQL 异常），Spring 会自动回滚事务 → 保证转账原子性。
    

---

### 2️⃣ 使用事务的最佳实践

## (1) 什么情况要用事务？

- **多表写操作**：比如订单系统，要同时插入订单表、更新库存表、修改账户余额。
    
- **一组必须原子性执行的操作**：比如转账、批量写入。
    
- **幂等性差的操作**：容易造成脏数据，需要回滚保障。
    

## (2) 什么情况不要滥用事务？

- **只读查询**：大部分 `SELECT` 不需要事务。可以用 `@Transactional(readOnly=true)` 优化（Spring 会跳过部分开销）。
    
- **大批量操作**：事务时间过长会导致锁竞争，建议分批提交。
    

---

### 3️⃣ `@Transactional` 的关键参数

```java
@Transactional(
    propagation = Propagation.REQUIRED,   // 事务传播行为
    isolation = Isolation.REPEATABLE_READ, // 事务隔离级别
    timeout = 30,  // 超时时间
    rollbackFor = Exception.class, // 哪些异常触发回滚
    readOnly = false // 是否只读
)
```

### 解释几个核心：

- **propagation（传播行为）**
    
    - `REQUIRED`（默认）：如果当前有事务，就加入事务，否则新建一个事务。
        
    - `REQUIRES_NEW`：不管有没有事务，都新建事务（原来的挂起）。
        
    - `NESTED`：嵌套事务，部分失败可以单独回滚。
        
- **isolation（隔离级别）**  
    对应 MySQL 的隔离级别（`READ_COMMITTED`、`REPEATABLE_READ` 等）。
    
    - Spring 默认：`DEFAULT` → 使用数据库默认（MySQL InnoDB 默认是 `REPEATABLE READ`）。
        
- **rollbackFor**
    
    - Spring 默认只在 **运行时异常 (RuntimeException)** 回滚。
        
    - 如果你想遇到所有异常都回滚，要写：
        
        ```java
        @Transactional(rollbackFor = Exception.class)
        ```
        

---

### 4️⃣ Spring Boot 写 MySQL 代码的建议

✅ **建议 1：一个业务方法 = 一个事务**

- 把逻辑拆分到 service 层，DAO 层只负责单表操作。
    
- 在 service 方法上加 `@Transactional`。
    

✅ **建议 2：避免事务里写太多 SQL**

- 大事务容易锁表/锁行，建议拆小事务或批处理。
    

✅ **建议 3：读写分离**

- 查询走从库（不用事务或只读事务）。
    
- 写操作走主库（事务保证一致性）。
    

✅ **建议 4：善用 `rollbackFor`**

- 不要只依赖默认的 RuntimeException 回滚，很多 Checked 异常（比如 `SQLException`）也要回滚。
    

✅ **建议 5：日志 + 异常捕获**

- 在事务方法里要记录关键日志，方便排查事务回滚原因。
    

---

### 5️⃣ 示例代码

```java
@Service
public class OrderService {
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private InventoryMapper inventoryMapper;

    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Long userId, Long productId, int quantity) {
        // 1. 创建订单
        orderMapper.insertOrder(userId, productId, quantity);

        // 2. 扣减库存
        inventoryMapper.decreaseStock(productId, quantity);

        // 3. 模拟异常（比如库存不足）
        if (quantity > 100) {
            throw new RuntimeException("下单失败，数量过大！");
        }

        // 如果异常 → 整个事务回滚（订单、库存操作都不执行）
    }
}
```

---

### ✅ 总结

- `@Transactional` 是 Spring Boot 操作事务的核心注解。
    
- 自动帮你 **开启、提交、回滚事务**。
    
- 用于 **多表操作、写操作**，避免数据不一致。
    
- 需要注意 **传播行为、隔离级别、回滚策略**。
    
- 写 MySQL 代码时建议 **service 层负责事务，DAO 层只负责 SQL**。
    



# 锁


### 核心概念与比喻

想象一下，我们把数据库的一张表看作是一本**电话簿**，里面的每一行记录就是一条**电话号码记录**。

-   **行锁 (Record Lock)**：锁住电话簿里**一条具体的记录**。比如，锁住“张三”的那一行，别人就不能修改或删除张三的信息。
-   **间隙锁 (Gap Lock)**：锁住电话簿里**两个相邻记录之间的“间隙”**。比如，锁住“李四”（第10条）和“王五”（第11条）之间的空白位置，防止任何人在这个空隙里插入一条新的记录。
-   **临键锁 (Next-Key Lock)**：它是 **行锁 + 间隙锁** 的组合。它锁住一条记录**以及该记录之前的间隙**。比如，锁住“王五”（第11条）这条记录**以及**“李四”和“王五”之间的间隙。这是MySQL默认的锁模式。

---

### 详细解释

#### 1. 行锁 (Record Lock)

-   **是什么**：锁住**索引项**对应的具体一行数据。
-   **目的**：防止其他事务对**已存在的这一行**进行`UPDATE`或`DELETE`操作，保证数据在事务期间的一致性。
-   **触发条件**：在`READ COMMITTED`和`REPEATABLE READ`隔离级别下，对使用**唯一索引**（如主键）进行**精确匹配**（如 `WHERE id = 5`）的查询进行加锁时，会使用行锁。
-   **例子**：
    ```sql
    -- 事务A
    BEGIN;
    SELECT * FROM users WHERE id = 10 FOR UPDATE; -- 对id=10这一行加行锁（写锁）

    -- 事务B
    UPDATE users SET name = 'foo' WHERE id = 10; -- 会被阻塞，等待事务A释放锁
    UPDATE users SET name = 'bar' WHERE id = 11; -- 可以正常执行，不受影响
    ```

#### 2. 间隙锁 (Gap Lock)

-   **是什么**：锁住索引项之间的**范围**，但不包括索引项本身。它锁的是一个“开区间”，例如 `(5, 10)`。
-   **目的**：**防止幻读（Phantom Read）**。防止其他事务在锁定的间隙中**插入**新的数据，从而保证在同一个事务中多次执行相同的查询，看到的结果集是一致的。
-   **触发条件**：仅在 `REPEATABLE READ`（MySQL默认隔离级别）及以上隔离级别生效。通常在**范围查询**或**查询不存在的记录**时使用**非唯一索引**（或没走索引）时触发。
-   **例子**：
    假设表中有`id`为 5, 10, 15 的记录。
    ```sql
    -- 事务A
    BEGIN;
    SELECT * FROM users WHERE id BETWEEN 10 AND 15 FOR UPDATE;
    -- 不仅锁住了id=10和15的现有行，还会锁住(5,10), (10,15), (15, +∞) 这些间隙。

    -- 事务B
    INSERT INTO users (id, name) VALUES (12, 'new'); -- 试图在(10,15)的间隙插入，会被阻塞！
    INSERT INTO users (id, name) VALUES (20, 'new'); -- 试图在(15, +∞)的间隙插入，也会被阻塞！
    INSERT INTO users (id, name) VALUES (3, 'new');  -- 在(负无穷,5)的间隙插入，可以成功（如果这个间隙没被锁）
    ```

#### 3. 临键锁 (Next-Key Lock)

-   **是什么**：**行锁 + 间隙锁** 的组合。它锁住一条记录以及该记录之前的间隙。它是一个“左开右闭”的区间，例如 `(5, 10]`。
-   **目的**：同样是**防止幻读**。它是MySQL在 `REPEATABLE READ` 隔离级别下**默认的加锁算法**。
-   **如何工作**：当MySQL执行查询时，它会为扫描到的每一个索引项加上临键锁。这样既锁住了已经存在的记录（防止修改），也锁住了记录之间的间隙（防止插入）。
-   **例子**：
    同样假设有`id`为 5, 10, 15 的记录。
    ```sql
    -- 事务A
    SELECT * FROM users WHERE id > 9 AND id < 16 FOR UPDATE;

    -- MySQL可能会加以下临键锁：
    -- (5, 10] -- 锁住10这条记录和它之前的间隙
    -- (10, 15] -- 锁住15这条记录和它之前的间隙
    -- (15, +∞) -- 锁住15之后的正无穷间隙（这是一个特殊的间隙锁）

    -- 因此，任何试图插入id=6, id=11, id=16的操作都会被阻塞。
    -- 任何试图修改或删除id=10或id=15的操作也会被阻塞。
    ```

### 关系与区别总结

| 锁类型 | 锁定范围 | 主要目的 | 生效的隔离级别 | 比喻 |
| :--- | :--- | :--- | :--- | :--- |
| **行锁 (Record Lock)** | **具体的某一行** | 防止已存在的记录被修改或删除 | `READ COMMITTED`, `REPEATABLE READ` | 锁住电话簿里“张三”这一行 |
| **间隙锁 (Gap Lock)** | **行与行之间的间隙** | **防止插入**新数据，解决幻读 | `REPEATABLE READ` 及以上 | 锁住“李四”和“王五”之间的空白，不让写新名字 |
| **临键锁 (Next-Key Lock)** | **行 + 该行之前的间隙** | **防止插入和修改**，解决幻读 | `REPEATABLE READ`（默认算法） | 锁住“王五”这行**以及**“李四”和“王五”之间的空白 |

**关系**：
-   临键锁 = 行锁 + 间隙锁
-   间隙锁是临键锁的一部分。
-   在**唯一索引**的**等值查询**时，临键锁会**退化成行锁**（因为不需要锁间隙来防止幻读，已经能唯一确定一行了）。
-   对于**普通索引**或**范围查询**，临键锁是防止幻读的关键。

### 如何查看和排查锁？

如果你遇到锁等待或死锁，可以使用这些命令：
```sql
-- 查看当前正在发生的锁等待
SHOW ENGINE INNODB STATUS;

-- 查看信息_schema库中的锁信息（MySQL 5.7+）
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
```

理解这些锁机制，能帮助你更好地设计数据库索引、编写SQL语句，以及分析和解决生产中复杂的并发问题。



你这两个问题问得非常非常好，直击了 InnoDB 并发控制机制的两个核心且容易混淆的概念：**锁 (Locking)** 和 **多版本并发控制 (MVCC - Multiversion Concurrency Control)**。

它们的职责不同，协同工作来解决不同的问题。我们来彻底讲清楚。

---

### 问题一：加锁只加在索引项，不是有可能其他事务修改数据行的其他列吗？

**你的担心是对的，但锁机制能防止这种情况。关键在于理解锁的“对象”和“作用”。**

1.  **锁加在索引上，但保护的是数据**：
    -   虽然锁是加在**索引项**上的，但这个索引项（尤其是主键索引）**直接指向最终的数据行**。
    -   当一个事务持有了某条记录的 **X锁（排他锁）** 时，其他任何事务都无法再获得这条记录的 X锁 或 S锁（共享锁）。
    -   **“修改数据行的其他列”这个操作本身，就需要先获取该行的 X锁**。既然第一个事务已经持有了X锁，那么第二个事务在尝试修改（也需要获取X锁）时就会被阻塞，直到第一个事务释放锁。

**举个例子：**
-   **事务A** 执行：`UPDATE users SET balance = balance - 100 WHERE id = 1;`
    -   InnoDB 在 `id=1` 这个主键索引项上设置了 X锁。
-   **事务B** 试图执行：`UPDATE users SET name = 'Bob' WHERE id = 1;` （试图修改另一列）
    -   事务B也需要在 `id=1` 这个索引项上获得 X锁。
    -   但它发现事务A已经持有了X锁，因此**事务B会被挂起，进入锁等待状态**。
    -   直到事务A提交或回滚，释放了X锁，事务B才能继续执行。

**结论**：锁加在索引上，但通过控制索引项的访问，有效地**保护了整行数据**，防止其他事务以任何方式（修改任何列）访问被锁定的行（除非是快照读）。

---

### 问题二：SELECT读副本，修改操作改变最新版本，所以加锁不影响SELECT？

**完全正确！这正是 MVCC 机制的精髓所在，它完美地解决了“读写冲突”的问题。**

InnoDB 通过 **MVCC** 和 **锁** 这两套机制来应对不同的并发场景：

| 机制 | 解决什么冲突？ | 如何工作？ | 效果 |
| :--- | :--- | :--- | :--- |
| **MVCC** | **读写冲突** (Read-Write) | 为每个数据行维护多个历史版本。`SELECT` 查询会基于某个时间点（事务开始时的系统版本号）创建一个**一致性读视图**，只读取在该时间点之前已经提交的数据快照。 | **读不阻塞写，写不阻塞读**。读写操作可以并发进行，极大提升了性能。 |
| **锁** | **写写冲突** (Write-Write) | 当数据要被修改时，使用锁（主要是X锁）来确保同一时刻只有一个事务能修改某条数据。 | **写操作会相互阻塞**。保证了数据的最终一致性，防止更新丢失。 |

**把它们放在一个场景里就非常清晰了：**

假设 `users` 表中有一条记录：`id = 1, name = 'Alice', balance = 1000`。

1.  **时刻 T1**：
    -   **事务A** (隔离级别 `REPEATABLE READ`) 开始：`BEGIN;`
    -   **事务A** 执行：`SELECT balance FROM users WHERE id = 1;` // 读到 1000
    -   此时，事务A基于T1时刻创建了一个**读视图**。

2.  **时刻 T2**：
    -   **事务B** 开始并执行：`UPDATE users SET balance = 900 WHERE id = 1;` // 成功获取X锁，修改数据。
    -   此时，InnoDB 并不是直接覆盖原数据，而是：
        -   将 `balance = 1000` 的旧版本数据存入 **undo log**。
        -   将当前行的数据更新为 `balance = 900`，并更新一个版本号。

3.  **时刻 T3**：
    -   **事务A** 再次执行：`SELECT balance FROM users WHERE id = 1;`
    -   它**不会去读最新的数据**（900），而是会去 **undo log** 中寻找符合它读视图时间点的历史版本数据，所以它读到的依然是 **1000**。（这就是“可重复读”）
    -   **与此同时，事务B的写操作完全不受事务A读操作的影响，它早已完成。**

4.  **时刻 T4**：
    -   **事务B** 提交：`COMMIT;`
    -   **事务C** 开始并执行：`SELECT ... FROM users WHERE id = 1;` // 因为事务C是在事务B提交后开始的，它的读视图会包含事务B的提交，所以它会读到最新的值 **900**。

5.  **时刻 T5**：
    -   如果此时有**事务D** 尝试执行 `UPDATE users SET balance = 800 WHERE id = 1;`，它会**被阻塞**，因为**事务A仍然持有id=1的行锁吗？不，事务A是读操作，默认不加锁。**
    -   这里需要修正：**普通SELECT不加锁，所以不会阻塞事务D**。事务D会成功获取X锁并执行更新。

**整个过程的核心要点：**

-   **SELECT (快照读)**：访问的是**历史版本**，像一个旁观者，不打扰任何人，也不需要被任何人打扰。它不受锁的影响。
-   **UPDATE/DELETE (当前读)**：访问的是**最新版本**，并且必须给数据加锁，像一个修改者，需要独占权限，会阻止其他修改者。
-   **锁**：是**写写操作**之间的“交通信号灯”，防止两个修改者同时操作一条数据，造成混乱。
-   **MVCC**：是**读写操作**之间的“平行宇宙”，让读者和写者各自在不同的时间线上工作，互不阻塞。

所以，你的理解是完全正确的：**加锁是为了防止“写写冲突”，而MVCC通过维护多版本解决了“读写冲突”。** 正是这两套机制的高效协同，才使得 InnoDB 能在保证事务隔离性的同时，提供极高的并发性能。


### 加锁过程


#### 场景

表 `t` 有一个主键索引 `id`，已有数据如下：

```
id = 1, 2, 5, 9, 10
```

---

####  查询一行 + 加锁

```sql
SELECT * FROM t WHERE id = 9 FOR UPDATE;
```

🔒 加锁范围：

```
(-∞ , 1)   → 间隙锁
[1]        → 行锁
(1 , 2)    → 间隙锁
[2]        → 行锁
(2 , 5)    → 间隙锁
[5]        → 行锁
(5 , 9)    → 间隙锁
[9]        → 行锁（你要的行）
(9 , 10)   → 间隙锁
[10]       → 行锁
(10 , +∞)  → 间隙锁
```

👉 关键点：

- `id=9` 被 **行锁** 锁住。
    
- `id=9` 前后的空隙 `(5,9)`、`(9,10)` 被 **间隙锁** 锁住。
    
- 防止其他事务插入 **id=8、id=9.5** 之类的数据，避免幻读。
    

---

#### 查询范围 + 加锁

```sql
SELECT * FROM t WHERE id BETWEEN 2 AND 9 FOR UPDATE;
```

🔒 加锁范围：

```
(1 , 2)    → 间隙锁
[2]        → 行锁
(2 , 5)    → 间隙锁
[5]        → 行锁
(5 , 9)    → 间隙锁
[9]        → 行锁
(9 , 10)   → 间隙锁
```

👉 关键点：

- `id=2, 5, 9` 被行锁锁住。
    
- 中间的空隙也被锁住 → 防止别人插入 3、4、6、7、8 这些新行。
    

---

####  没有索引，全表扫描

```sql
SELECT * FROM t WHERE id = 9 FOR UPDATE;
```

但 **id 没有索引**，只能全表扫描。

🔒 加锁方式：

- 从第一行开始，逐行判断 + 加锁。
    
- 直到扫完整个表，所有行都被锁住。
    
- 效果 ≈ 表锁。
    

---

✅ **总结图解**

- **行锁**：锁住实际存在的行（用 `[ ]` 表示）。
    
- **间隙锁**：锁住两行之间的范围（用 `( )` 表示）。
    
- **没有索引**：全表行锁，间隙锁失效（因为无法确定范围）。
    



### 数据存储

#### 1. MySQL 数据存储在哪？

- MySQL 常用存储引擎是 **InnoDB**（默认）。
    
- 每张表对应 **一个表空间文件**（早期 `.ibd` 文件，现在也可能存在在共享表空间 `ibdata1` 里）。
    
- 表空间文件里存储：
    
    - **数据页 (Data Page)**
        
    - **索引页 (Index Page)**
        
    - **Undo/Redo 日志片段**
        
    - **其他系统信息**
        

👉 所以物理上，数据就在 **磁盘文件**里（表空间）。

---

#### 2. 存储的基本单位：页 (Page)

InnoDB 默认页大小是 **16KB**。  
页是最小的存储和读写单位。

常见的页类型：

- **数据页 (Leaf Page)**：存表的实际行数据。
    
- **索引页 (Non-leaf Page)**：存索引键 + 指针（指向下一层页）。
    
- **Undo Page**：存回滚信息。
    
- **其他元数据页**。
    

👉 所以每次查询，MySQL 最小会加载一页（16KB）到内存里（Buffer Pool）。

---

#### 3. 行数据的存储

在数据页里，每一行的存储大致包含：

- **隐藏列**（事务 ID，回滚指针，行 ID）。
    
- **用户定义列**（你的表字段，比如 `id, name, age`）。
    
- **NULL 标志位**（字段是否为 NULL）。
    
- **变长字段长度表**（VARCHAR 等字段的长度）。
    

👉 所以 MySQL 实际上一行数据比你定义的字段要多，InnoDB 会自动加上事务控制需要的隐藏信息。

---

#### 4. 主键索引 (Clustered Index)

这是 InnoDB 的核心：

- InnoDB **必须有一个主键**，如果你没定义，它会自动生成一个。
    
- **数据按照主键顺序，存放在 B+Tree 的叶子节点里**。
    
    - 叶子节点 = **整行数据**。
        
    - 非叶子节点 = **索引键 + 指针**。
        
- 因为主键索引存了“数据本身”，它又叫 **聚簇索引 (Clustered Index)**。
    

👉 所以你可以理解为：  
表的数据本身就是一棵 **主键 B+Tree**。

---

#### 5. 二级索引 (Secondary Index)

如果你在 `name` 上建了索引：

- InnoDB 会再建一棵 B+Tree。
    
- **叶子节点不是整行数据，而是主键值**。
    
- 查询时：
    
    1. 先走 `name` 索引 → 找到主键 ID。
        
    2. 再用主键去主键索引树里找数据。
        
- 这个过程叫 **回表 (Back to Clustered Index)**。
    

👉 这就是为什么说 **InnoDB 的二级索引必须依赖主键索引**。

---

#### 6. 查询过程示例

假设表：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  age INT
);
```

数据：

|id|name|age|
|---|---|---|
|1|A|20|
|2|B|21|
|3|C|22|

---

 例 1：`SELECT * FROM user WHERE id = 2;`

- 直接走 **主键 B+Tree**。
    
- 从根节点查到叶子节点 → 直接拿到整行 `(2, B, 21)`。
    
- **O(logN)** 查找效率。
    

---

 例 2：`SELECT * FROM user WHERE name = 'B';`

- 走 **name 二级索引 B+Tree**。
    
- 找到 `name='B'` → 得到主键 `id=2`。
    
- 再回表到 **主键 B+Tree**，拿到 `(2, B, 21)`。
    
- 这比全表扫描快很多。
    

---

 例 3：`SELECT * FROM user WHERE age=21;`

- 如果 `age` 没有索引 → 必须 **全表扫描**。
    
- 扫描每个页，每行比对 `age` 字段。
    
- 速度就会慢。
    

---

#### 7. 总结

- **数据实际存储**：表空间文件里，按页存储，主键索引 B+Tree 的叶子节点就是整行数据。
    
- **查询原理**：走主键索引时直达数据；走二级索引时要回表；没索引时只能全表扫描。
    
- **高效的关键**：索引（尤其是主键索引）决定了数据组织结构和访问路径。
    

---

要不要我帮你画一张 **图解：主键索引树 + 二级索引树 → 查询路径**，这样你能一眼看到 MySQL 数据是怎么“长在树里”的？