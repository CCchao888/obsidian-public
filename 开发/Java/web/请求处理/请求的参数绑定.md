

从“网络字节流”到“Java对象”的魔法过程，不同框架的处理方式有差异，但核心思想相似。

下面通过一个详细的流程图，结合步骤分解，来展示这个完整的过程。

```mermaid
flowchart TD
A[前端发起请求] --> B[网络传输 HTTP/HTTPS]
B --> C{请求到达 Web 服务器<br>（Tomcat/Jetty/Netty）}

C --> D[服务器创建<br>HttpServletRequest 对象]
D --> E[框架层介入<br>（Spring MVC / JAX-RS）]

subgraph F[Spring MVC 处理流程]
    direction LR
    F1[DispatcherServlet<br>接收请求] --> F2[查找匹配的<br>@Controller @RequestMapping]
    F2 --> F3[选择参数解析器<br>Parameter Resolver]
end

subgraph G[JAX-RS 处理流程]
    direction LR
    G1[JAX-RS Implementation<br>（如CXF） 接收请求] --> G2[查找匹配的<br>@Path 方法]
    G2 --> G3[根据注解选择<br>MessageBodyReader/ParamConverter]
end

E --> F
E --> G

F3 --> H[解析与转换]
G3 --> H

subgraph H[解析与转换]
    H1[读取请求数据<br>（查询字符串/请求体/Header）] --> H2[数据转换与类型绑定<br>（String to Integer/Long/Date等）]
    H2 --> H3[数据验证<br>（Validation）]
end

H3 --> I[调用目标方法<br>传入解析好的实参]
I --> J[方法执行]
J --> K[框架将返回值<br>转换为HTTP响应]
K --> L[Web服务器发送响应]
L --> M[前端接收响应]
```

上图展示了完整的流程，现在来详细分解图中的关键步骤：

### 步骤分解：从请求到实参的“魔法”

#### 第1步：Web服务器接收请求
-   前端发送的HTTP请求（只是一串字节流）到达Tomcat等服务器。
-   服务器解析HTTP协议，将请求头、请求体等信息封装成一个Java对象：**`HttpServletRequest`**。
-   这个对象包含了所有原始的、未处理的信息。

#### 第2步：框架介入（这里开始出现差异）
框架（Spring MVC / JAX-RS）的“入口”（如Spring的 `DispatcherServlet`）接手这个 `HttpServletRequest` 对象。

#### 第3步：查找匹配的处理方法
框架根据URL路径，找到对应的 `@Controller` 中的 `@RequestMapping` 方法（Spring MVC）或 `@Path` 方法（JAX-RS）。

#### 第4步：【最关键的差异点】参数解析
**这是不同框架区别最大的地方！** 框架如何知道方法参数 `String name` 该从哪里取值？

**a) Spring MVC 的方式：靠“注解”或“位置”**
Spring MVC 有一系列的 **`HandlerMethodArgumentResolver`** (参数解析器)。

-   **如果参数有 `@RequestParam`**：解析器会从 `HttpServletRequest` 的**参数列表**（URL查询字符串或表单体）中按名字获取值。
    ```java
    // Spring MVC 会调用：request.getParameter("name") 来获取值
    public String method(@RequestParam String name)
    ```

-   **如果参数有 `@RequestBody`**：解析器会读取整个**请求体**，并使用 `HttpMessageConverter`（如Jackson）将JSON字符串反序列化成Java对象。
    ```java
    // Spring MVC 会调用：Jackson 将 request body 的 JSON 转为 User 对象
    public String method(@RequestBody User user)
    ```

-   **如果参数是自定义对象且无注解**：Spring MVC 会尝试进行**“属性级”绑定**，相当于为对象的每个属性自动执行 `@RequestParam`。
    ```java
    // Spring MVC 会尝试：user.setName(request.getParameter("name"));
    //                   user.setAge(Integer.parseInt(request.getParameter("age")));
    public String method(User user)
    ```

**b) JAX-RS (如CXF) 的方式：靠“注解”**
JAX-RS 的标准更严格，**每个参数都必须有明确的来源注解**。

-   **`@QueryParam`**：从URL查询字符串中获取。
    ```java
    // CXF 从 URL 的 ?name=xxx 中获取值
    public Response method(@QueryParam("name") String name)
    ```

-   **`@FormParam`**：从表单提交的请求体中获取。
    ```java
    // CXF 从 POST 的 body (name=xxx&age=25) 中获取值
    public Response method(@FormParam("name") String name)
    ```

-   **无注解的参数**：通常被视为**请求体**，需要使用 `MessageBodyReader` 来转换（如从JSON转换）。
    ```java
    // CXF 会尝试用 JAXB 或 Jackson 等将请求体转为 User
    public Response method(User user)
    ```

#### 第5步：类型转换
框架拿到的是一个 `String` 类型的值（因为HTTP协议中所有值本质都是字符串）。如果方法参数是 `Integer`, `Long`, `Date` 等类型，框架会**自动尝试转换**。
-   `"123"` -> `Integer.valueOf(123)`
-   如果转换失败（如把 `"abc"` 转成 `Integer`），框架会抛出异常（如 `TypeMismatchException`）。

#### 第6步：处理“未传值”的情况

** “前端没传”对于后端框架来说，就是 **`null`**。

-   框架在 `HttpServletRequest` 对象上调用 `getParameter("name")` 方法。
-   如果前端没传这个参数，该方法**返回 `null`**。
-   框架拿着这个 `null` 值，去进行后续操作。

**后续操作的区别，造成了不同框架/配置的不同行为：**

1.  **Spring MVC 的 `@RequestParam`**：
    -   **默认**：`required = true`。框架拿到 `null` 后，发现这个参数是必需的，于是**直接抛出 `MissingServletRequestParameterException`**，根本不会去调用你的方法。
    -   **设置 `required = false`**：框架拿到 `null`，发现参数不是必需的，于是**将这个 `null` 值作为实参传递给**你的方法。你在方法里就会收到 `name = null`。

2.  **Spring MVC 的“属性级绑定”**：
    -   框架拿到 `null`，会直接调用 `user.setName(null)`。你的对象属性就是 `null`。

3.  **JAX-RS 的 `@QueryParam`**：
    -   行为类似 `@RequestParam(required = false)`。它更宽松，默认就是可选的，直接传递 `null` 给方法。

4.  **基本类型 `int` vs 包装类型 `Integer`**：
    -   如果方法参数是 `int name`，框架试图将 `null` 赋值给 `int`，这是不可能的，所以会报错。
    -   如果方法参数是 `Integer name`，`null` 可以成功赋值。

### 总结

| 环节 | 发生了什么 | 框架差异 |
| :--- | :--- | :--- |
| **1. 网络传输** | HTTP 字节流 | 无差异 |
| **2. 服务器解析** | 封装为 `HttpServletRequest` | 无差异 |
| **3. 框架路由** | 根据URL找到处理方法 | 注解不同（`@RequestMapping` vs `@Path`） |
| **4. 参数解析** | **核心差异**！根据注解决定从哪取数据 | Spring MVC 支持无注解绑定，JAX-RS 必须要有注解 |
| **5. 类型转换** | `String` -> `Integer`/`Date` 等 | 类似 |
| **6. 空值处理** | **关键**！`null` 的传递与否由框架规则决定 | Spring MVC 默认严格，JAX-RS 默认宽松 |

所以，你的认知非常准确：**前端不传值，后端框架获取到的就是 `null`。** 最终这个 `null` 是否会成为你方法的实参，取决于你使用的**框架类型**和**具体的注解配置**。这个“魔法”过程，其实就是框架帮你自动完成了一系列从 `HttpServletRequest` 中提取、转换、传递数据的工作。