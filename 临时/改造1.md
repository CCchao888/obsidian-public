分三部分讲解：

1. **同一个接口在 CXF（JAX-RS）里的写法**
    
2. **迁移到 Spring MVC 的写法**
    
3. **调用端（FeignClient）需要怎么改**
    

---

# 1. CXF JAX-RS 的写法

### 接口类

```java
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import java.util.List;

@Path("/product")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public interface ProductService {

    @GET
    @Path("/{id}")
    Product getProduct(@PathParam("id") String id);

    @POST
    @Path("/create")
    Product createProduct(Product product);

    @GET
    @Path("/list")
    List<Product> list();
}
```

### 实现类

```java
import org.springframework.stereotype.Service;

@Service
public class ProductServiceImpl implements ProductService {
    @Override
    public Product getProduct(String id) {
        return new Product(id, "电脑");
    }

    @Override
    public Product createProduct(Product product) {
        return product;
    }

    @Override
    public List<Product> list() {
        return List.of(new Product("1", "电脑"));
    }
}
```

### XML 配置暴露接口

```xml
<jaxrs:server id="jaxrsServer" address="/services">
    <jaxrs:serviceBeans>
        <ref bean="productServiceImpl"/>
    </jaxrs:serviceBeans>
</jaxrs:server>
```

**访问路径**：

```
http://host:port/应用上下文/services/product/1
```

---

# 2. Spring MVC 的写法（改造后）

**去掉 jaxrs:server 配置**，直接用注解。

### Controller 写法

```java
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/product")
public class ProductController {

    @GetMapping("/{id}")
    public Product getProduct(@PathVariable String id) {
        return new Product(id, "电脑");
    }

    @PostMapping("/create")
    public Product createProduct(@RequestBody Product product) {
        return product;
    }

    @GetMapping("/list")
    public List<Product> list() {
        return List.of(new Product("1", "电脑"));
    }
}
```

**访问路径**：

```
http://host:port/应用上下文/product/1
```

（不再需要 `/services` 前缀，除非你自己在 application.yml 配置了 `server.servlet.context-path=/services`）

---

# 3. FeignClient 的改造

**旧的 FeignClient（JAX-RS 风格）**

```java
@FeignClient(name = "basic", path = "/services/product")
public interface ProductClient {

    @GetMapping("/{id}")
    Product getProduct(@PathVariable("id") String id);

    @PostMapping("/create")
    Product createProduct(@RequestBody Product product);

    @GetMapping("/list")
    List<Product> list();
}
```

---

**改造后的 FeignClient（Spring MVC 风格）**

因为 Spring MVC 暴露路径变了（去掉 `/services`），FeignClient 的 `path` 要对应调整：

```java
@FeignClient(name = "basic", path = "/product")
public interface ProductClient {

    @GetMapping("/{id}")
    Product getProduct(@PathVariable("id") String id);

    @PostMapping("/create")
    Product createProduct(@RequestBody Product product);

    @GetMapping("/list")
    List<Product> list();
}
```

> Feign 本身是基于 Spring MVC 注解（`@GetMapping`, `@PostMapping`）去描述接口，所以调用方式不变，只是 `path` 根据服务端的新路径调整。

---

# 迁移注意事项

1. **去掉 XML 配置**，用 Spring Boot 默认自动装配
    
2. **路径调整**：注意旧接口是否保留 `/services` 前缀
    
3. **调用方（Feign）**：更新 `@FeignClient(path = ...)`
    
4. **网关**：如果有网关，可能还要更新路由路径
    

---

# 迁移后的调用流转

**前端**

```
GET /api/product/1
```

**网关**

- 转发到 Nacos 注册的 `basic` 服务 `/product/1`
    

**basic 服务**

- `@RestController` 方法处理请求，返回 JSON
    

---

## 预研

- 列一个“接口映射表”（旧地址 vs 新地址）
    
- 做一个 demo 服务跑通
    
- 更新一个 FeignClient 调用验证
    

---

