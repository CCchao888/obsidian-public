



## 1. **JAX-RS (@QueryParam) 的行为**

```java
@GET
@Path("/users")
public List<User> listUsers(@QueryParam("name") String name) {
    ...
}
```

- 前端请求：`/users?name=Tom` → `name="Tom"`
    
- 前端请求：`/users`（没传 `name`） → `name=null`
    

👉 **JAX-RS 默认允许参数缺省**，参数没传就变成 `null`。所以你的旧代码能跑。

---

## 2. **Spring MVC (@RequestParam) 的行为**

```java
@GetMapping("/users")
public List<User> listUsers(@RequestParam("name") String name) {
    ...
}
```

- 默认情况下，Spring MVC 认为 `@RequestParam` 是 **必须的**。  
    如果没传，直接报错：
    
    ```
    Required request parameter 'name' for method parameter type String is not present
    ```
    
- 要让它可选，需要加：
    
    ```java
    @RequestParam(value = "name", required = false)
    ```
    
    这样如果前端没传参，`name=null`，就和原来的 JAX-RS 行为一致了。
    

---

## 3. **参数没有加注解的情况**

### JAX-RS

```java
public List<User> listUsers(UserQuery query);
```

如果参数是个对象（POJO），JAX-RS 默认会尝试从：

- Query 参数 (`?name=Tom&age=18`)
    
- 或请求体（POST/PUT JSON）  
    去填充字段。没传的字段 = `null`。
    

### Spring MVC

```java
public List<User> listUsers(UserQuery query);
```

默认等价于 `@ModelAttribute UserQuery query`，也会把 query string 里的参数自动绑定到对象属性上：

- `?name=Tom&age=18` → `query.name="Tom", query.age=18`
    
- 没传的字段 = `null`
    

👉 所以这种场景，你不用加 `@RequestParam`，直接保留对象参数就行。

---

## 4. **@RequestBody 的区别**

- `@RequestBody` 绑定的是请求体（JSON / XML）。
    
- 如果用 `@RequestBody`，前端必须传 JSON，否则报错 400。
    
- 而你原来 JAX-RS 里没有 `@RequestBody`，那说明参数是 query/form 传的，不要强行加 `@RequestBody`。
    

---

## 5. **Feign Client 的行为**

Feign 调用时，接口注解要和服务端保持一致：

- **query 参数**：
    
    ```java
    @GetMapping("/users")
    List<User> listUsers(@RequestParam(value="name", required=false) String name);
    ```
    
    → Feign 会拼 URL：`/users?name=Tom`
    
- **请求体**：
    
    ```java
    @PostMapping("/users")
    User createUser(@RequestBody User user);
    ```
    
    → Feign 会把 `user` 序列化为 JSON 放在 body 里。
    

⚠️ 如果你错用了 `@RequestBody`，前端和 Feign 调用方都要传 JSON，否则必然报错。

---

## ✅ 建议改造规则

结合你遇到的问题，我建议这样改：

1. **原来是 @QueryParam → 改成 @RequestParam(required=false)**  
    保持「参数可选，没传就是 null」。
    
2. **原来没有注解的对象参数 → 直接保留对象，不要加 @RequestBody**  
    这样 query 参数能自动绑定，没传字段 = null。
    
3. **只有明确走 JSON 请求体的接口 → 才用 @RequestBody**  
    否则不要乱加。
    

---

## 例子对比

### JAX-RS

```java
@GET
@Path("/users")
public List<User> listUsers(@QueryParam("name") String name,
                            @QueryParam("age") Integer age);
```

### Spring MVC

```java
@GetMapping("/users")
public List<User> listUsers(
        @RequestParam(value="name", required=false) String name,
        @RequestParam(value="age", required=false) Integer age) {
    ...
}
```

---

👉 总结：

- 报错的原因是：`@RequestParam` 默认 required=true。
    
- 解决方案：改成 `required=false`，或者把参数封装成对象。
    
- Feign 要和服务端保持注解一致，不要随便用 `@RequestBody`。
    


