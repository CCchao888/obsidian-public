
1. 检查配置文件的Jackson，数据库连接字符串，数据库时区
2. 检查dao.xml
3. 检查 ObjectMapper
4. 检查正常页面的前端时间传的格式，检查打分前端传的时间格式
5. 检查正常页面的后端响应的时间格式，检查打分后端响应的时间格式
6. 检查是不是前端时间截取写错了，导致被修改为不是ISO格式


    @JsonFormat(
        pattern = "yyyy-MM-dd HH:mm:ss", 
        timezone = "GMT+8",
        shape = JsonFormat.Shape.STRING
    )

spring:
  jackson:
    time-zone: Asia/Shanghai

@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
private LocalDateTime updateTime;





---

# 🧩 问题 1：返回前端时间少 8 小时（UTC ↔ 东八区偏移）

## 🧠 原因分析

你说得对：

> Java 从数据库获取时间是正确的（东八区），但返回前端时成了 UTC。

这正是因为：

- MyBatis 从 MySQL `datetime` 取出时 → 转成 `java.util.Date`（没有时区信息）；
    
- 你后端运行的 **JVM 默认时区 = UTC**；
    
- Jackson 在序列化（返回前端 JSON 时）默认以 **UTC 时区输出 ISO8601**。
    

因此，序列化时 Jackson 把你 JVM 当前时区（UTC）的时间输出为：

```
数据库存 2025-10-14 10:00:00
↓
Java 内部 new Date(2025-10-14T10:00:00+08:00)
↓ Jackson 以 UTC 输出 →
2025-10-14T02:00:00.000Z
```

---

## ✅ 解决方案

你有两种思路（任选一种）：

### ✅ 方案 1：在 Spring Boot 全局设置 Jackson 时区（推荐）

在 `application.yml` 里加：

```yaml
spring:
  jackson:
    time-zone: Asia/Shanghai
```

这样：

- Jackson 序列化时使用东八区；
    
- 你不需要在每个字段加 `@JsonFormat`；
    
- 前端收到的就是东八区时间（ISO 格式或自定义格式）。
    

---

### ✅ 方案 2：在代码中手动设置 JVM 默认时区

如果你不想改配置文件，可以在启动类里加：

```java
@PostConstruct
public void init() {
    TimeZone.setDefault(TimeZone.getTimeZone("Asia/Shanghai"));
}
```

效果一样：MyBatis 读出 → Date → Jackson 输出，全部东八区一致。

---

# 🧩 问题 2：加了 `@JsonFormat` 后，反而报错“不能把年月日时分秒变成 Date”

错误原文：

> cannot deserialize value of type 'java.util.Date' from String "2025-10-14 10:00:00"

## 🧠 原因分析

### 🔹 你需要知道两点：

1. `@JsonFormat` 同时作用于：
    
    - 序列化（返回前端）
        
    - 反序列化（接收前端）
        
2. Jackson 默认只识别 ISO8601 或时间戳，不识别 `"yyyy-MM-dd HH:mm:ss"` 这种字符串 unless 注册了 `SimpleDateFormat` 或时间模块。
    

所以：

- 你加了 `@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss")`；
    
- 前端传 `"2025-10-14 10:00:00"`；
    
- Jackson 尝试按你的 pattern 解析；
    
- 但默认的 `ObjectMapper` 没注册时间模块（`JavaTimeModule`）；
    
- 所以 Jackson 不知道该怎么把 `"2025-10-14 10:00:00"` 转成 `Date`；
    
- ❌ 就抛出了 “cannot deserialize value of type java.util.Date” 的异常。
    

---

## ✅ 解决方案

### ✅ 方案 1：在 Spring Boot 全局配置 Jackson 的日期格式

在 `application.yml` 中加入：

```yaml
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: Asia/Shanghai
```

效果：

- 前端传 `"yyyy-MM-dd HH:mm:ss"` → 能自动反序列化；
    
- 后端返回也是 `"yyyy-MM-dd HH:mm:ss"`；
    
- 不需要每个字段都写 `@JsonFormat`；
    
- 彻底统一序列化和反序列化格式。
    

---

### ✅ 方案 2：注册 Jackson 的 JavaTimeModule（代码方式）

如果是自定义配置类：

```java
@Configuration
public class JacksonConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        mapper.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return mapper;
    }
}
```

这样 Jackson 能正确解析 `"yyyy-MM-dd HH:mm:ss"` 格式的字符串 → `java.util.Date`。

---

### ✅ 方案 3（更现代、推荐）：改成 `LocalDateTime` 而不是 `Date`

```java
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
private LocalDateTime updateTime;
```

`LocalDateTime` 是 JDK8 时间类型，不带时区，配合 Jackson 自动支持序列化与反序列化 `"yyyy-MM-dd HH:mm:ss"`。  
比 `java.util.Date` 稳定、无时区偏移、无“减8小时”问题。

---

# ✅ 最终推荐组合（最稳）

如果你现在在一个 Spring Boot 项目里，我建议这样统一：

### 🔧 application.yml

```yaml
spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: Asia/Shanghai
```

### 📦 实体类

```java
// 推荐用 LocalDateTime，避免 Date 的 UTC 影响
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime updateTime;
```

---

# 🧾 总结表

|问题|原因|解决方案|
|---|---|---|
|返回时间少 8 小时|Jackson 序列化默认使用 UTC|`spring.jackson.time-zone=Asia/Shanghai`|
|加 @JsonFormat 报错|Jackson 反序列化不了自定义格式字符串|在全局配置 date-format 或注册 JavaTimeModule|
|想统一格式|Date/LocalDateTime 序列化格式不一致|`spring.jackson.date-format` 统一配置|
|想避免时区问题|Date 有 UTC 偏移|改用 `LocalDateTime`|

---

要不要我帮你看下：你现在这个项目用的是 Spring Boot 2 还是 3？（因为 3.x 默认 ObjectMapper 注册逻辑不太一样，我可以帮你写最适配的配置类。）