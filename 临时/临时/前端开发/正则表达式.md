

#### 1. 场景 A：0 到 100，最多 4 位小数

**正则表达式：**

代码段

```
^((0|[1-9]\d?)(\.\d{1,4})?|100(\.0{1,4})?)$
```

**解析（给后端视角的翻译）：**

- `^` 和 `$`：代表匹配整个字符串的头和尾。
    
- `( ... | ... )`：这是一个 OR 逻辑，分两种情况。
    
    - **情况 1 (0-99.xxxx)**：`(0|[1-9]\d?)` 匹配 0 或者 1-99；`(\.\d{1,4})?` 匹配可选的小数点后 1 到 4 位。
        
    - **情况 2 (100)**：`100` 匹配整数 100；`(\.0{1,4})?` 允许写成 100.0000（必须是 0，不能是 100.1）。
        

#### 2. 场景 B：-100 到 100，最多 4 位小数

**正则表达式：**

代码段

```
^-?((0|[1-9]\d?)(\.\d{1,4})?|100(\.0{1,4})?)$
```

**解析：**

- 就是在上面那个正则的最前面，加了一个 `-?`。
    
- `?` 代表“0 次或 1 次”，也就是“可能有负号，也可能没有”。


这是一个**非常标准、但又很容易被评委/导师追问“你是不是只写了个正则”**的问题。  
我会分 **“工程上正确的做法”** 来讲，而不是只丢一个正则。

你可以直接照这个讲，**前端同事 + 架构师都会认可**。

---

# 一、先给结论：**不要只靠一个正则**

> 正确做法是：  
> **输入约束（input） + 语义校验（number） + 边界校验（range） + 精度校验（scale）**

也就是说：  
👉 **多层校验，而不是一个 regex 搞定一切**

---

# 二、需求拆解（这是评委最想听的）

## 场景 1：

**0～100 的数字，最多 4 位小数**

含义拆解：

- 是数字（允许小数）
    
- 最小值 ≥ 0
    
- 最大值 ≤ 100
    
- 小数位 ≤ 4
    
- 允许 `0`, `0.1`, `99.9999`, `100`, `100.0000`
    
- 不允许 `100.00001`
    

---

## 场景 2：

**-100 ～ 100 的数字，最多 4 位小数**

多了一点：

- 可以是负数
    
- 其他规则相同
    

---

# 三、前端“正确”的校验思路（重要）

## ✅ Step 1：输入层约束（减少无效输入）

### HTML 层（如果是 `<input>`）

```html
<input
  type="text"
  inputmode="decimal"
/>
```

> **说明**：
> 
> - 不用 `type=number`（会有精度和体验问题）
>     
> - `inputmode=decimal` 让移动端键盘更友好
>     

---

## ✅ Step 2：格式校验（正则，只做“形状判断”）

### 0～100，最多 4 位小数（**仅格式**）

```js
const REGEX_0_100_FORMAT = /^(?:\d+)(?:\.\d{1,4})?$/
```

### -100～100，最多 4 位小数（**仅格式**）

```js
const REGEX_NEG_100_100_FORMAT = /^-?\d+(?:\.\d{1,4})?$/
```

⚠️ 注意：  
这一步 **不校验范围**，只判断：

- 是不是一个合法的“数字字符串”
    
- 小数位有没有超
    

---

## ✅ Step 3：数值范围校验（核心）

```js
function isInRange(value, min, max) {
  const num = Number(value)
  if (Number.isNaN(num)) return false
  return num >= min && num <= max
}
```

---

## ✅ Step 4：综合校验函数（推荐你在项目里用）

### 🎯 0～100，最多 4 位小数

```js
function validate0to100(value) {
  if (value === '' || value === null || value === undefined) {
    return { valid: false, msg: '不能为空' }
  }

  if (!/^(?:\d+)(?:\.\d{1,4})?$/.test(value)) {
    return { valid: false, msg: '请输入数字，最多4位小数' }
  }

  const num = Number(value)
  if (num < 0 || num > 100) {
    return { valid: false, msg: '请输入 0 到 100 之间的数值' }
  }

  return { valid: true }
}
```

---

### 🎯 -100～100，最多 4 位小数

```js
function validateNeg100to100(value) {
  if (!/^-?\d+(?:\.\d{1,4})?$/.test(value)) {
    return { valid: false, msg: '请输入合法数字，最多4位小数' }
  }

  const num = Number(value)
  if (num < -100 || num > 100) {
    return { valid: false, msg: '请输入 -100 到 100 之间的数值' }
  }

  return { valid: true }
}
```

---

# 四、为什么不推荐一个“超级正则”？（答辩加分点）

如果评委问你：

> “能不能用一个正则直接校验 0～100？”

你可以回答：

> 可以，但不推荐。  
> 因为：
> 
> 1. 正则可读性差，维护成本高
>     
> 2. 边界（100、100.0000）容易出 bug
>     
> 3. 数值语义本来就该用 number 判断
>     
> 4. 前后端统一规则更容易复用逻辑
>     

这是**工程化回答**。

---

# 五、如果是 Vue / 组件库里的写法（你可以这样说）

### 例：表单校验规则（伪代码）

```js
rules: [
  {
    validator: (_, value) => {
      const result = validate0to100(value)
      return result.valid
        ? Promise.resolve()
        : Promise.reject(result.msg)
    },
    trigger: ['blur', 'change']
  }
]
```

---

# 六、和你前面说的「动态校验」是一个体系

你可以这样总结（非常适合答辩）：

> 这个属于“动态规则驱动校验”，  
> 校验规则不是写死在组件里，而是根据业务规则（区间、精度、正负）动态组合的。

---

# 七、如果架构师继续追问 DFX（稳定性/健壮性）

你可以补一句：

- 前端校验只是第一层
    
- 后端会再次校验数值合法性
    
- 防止绕过前端或接口调用异常
    

---

## 如果你愿意

我可以帮你：

- 把这些校验抽成 **可复用的校验策略设计**（一页 PPT）
    
- 或模拟一个 **评委追问 3 连问**，帮你练回答
    

你想练哪一个？