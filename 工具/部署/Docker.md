[Docker 官方文档](https://docs.docker.com/)
[Docker教程](https://github.com/feixuek/docker)
[Docker中文网](https://docker.github.net.cn/)

# 基础

## 🐳 Docker 基础知识与核心概念

### 1. 为什么需要 Docker？

在传统环境中：

- 开发环境 = 一套软件版本（比如 MySQL5.7 + Python3.8）。
    
- 测试环境 = 另一套版本（比如 MySQL8.0 + Python3.11）。
    
- 部署到生产环境时，经常出现 “在我电脑上能跑，在你那不行” 的情况。
    

**Docker 的目标**：

- 提供一个 **统一、可移植、轻量级的运行环境**。
    
- 应用打包成 **镜像 (image)**，谁拿到镜像都能运行出一模一样的 **容器 (container)**。
    

**Docker 就是一个容器化平台**。

### 2. Docker 的核心概念

#### （1）镜像（Image）

- 类似于 **操作系统 + 应用程序的安装包**。
    
- 镜像是 **只读的模版**，描述了容器启动所需的环境。
    
- 镜像分层存储（基于 **UnionFS/OverlayFS**），每一层只保存差异，复用性高。
    
    - 例如：Ubuntu 基础镜像 → 安装 MySQL → 配置环境 → 得到 MySQL 镜像。
        

👉 命令：

```bash
docker pull mysql:8      # 拉取 MySQL8 镜像
docker images            # 查看本地镜像
```

---

#### （2）容器（Container）

- **容器 = 镜像的运行实例**。
    
- 容器在运行时是一个 **进程**，但与宿主机隔离（使用 namespace + cgroups 技术）。
    
- 容器是轻量级的，秒级启动，删除不影响镜像。
    

👉 命令：

```bash
docker run -d --name mydb mysql:8   # 基于镜像启动一个容器
docker ps                           # 查看运行中的容器
docker ps -a                        # 查看所有容器（包括已停止的）
```

---

#### （3）仓库（Registry）

- 存放镜像的地方。
    
- 官方的公共仓库是 **Docker Hub**。
    
- 公司也可以搭建 **私有仓库**（如 Harbor、AWS ECR、阿里云容器镜像服务）。
    

👉 命令：

```bash
docker push myrepo/myapp:1.0   # 推送镜像到仓库
docker pull nginx:latest       # 从仓库拉取镜像
```

---

#### （4）卷（Volume）

- 容器的数据是临时的，容器删了数据也没了。
    
- 卷用于 **持久化数据**，把宿主机目录挂载到容器里，容器与宿主机共享数据。
    

👉 命令：

```bash
docker run -v /host/data:/container/data mysql:8
```

---

#### （5）网络（Network）

- 默认情况下，容器跑在 **bridge 网络**，外界不能直接访问。
    
- 使用 `-p` 进行 **端口映射**，让宿主机端口转发到容器端口。
    
- 也可以创建自定义网络，让多个容器直接用 **名字互相通信**。
    

👉 命令：

```bash
docker run -p 8080:80 nginx
docker network create mynet
docker run --network=mynet --name=app1 myapp
docker run --network=mynet --name=db mysql:8
```

---

#### （6）Dockerfile

- 镜像不是凭空来的，而是用 **Dockerfile** 描述的。
    
- **Dockerfile = 镜像的配方**，定义了如何从基础镜像一步步构建新镜像。
    

👉 示例：

```dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y python3
COPY . /app
WORKDIR /app
CMD ["python3", "app.py"]
```

构建命令：

```bash
docker build -t myapp:1.0 .
```

---

### 3. Docker 的优势

- **跨平台一致性**：打包成镜像，在哪跑都一样。
    
- **轻量级**：相比虚拟机，容器不需要完整操作系统，只共享宿主机内核。
    
- **快速启动**：容器可以秒级启动。
    
- **弹性伸缩**：结合 Kubernetes，能轻松扩展上百上千个实例。
    

---

### 4. Docker 工作流程总结

1. 开发者写 `Dockerfile` → 构建镜像。
    
2. 镜像上传到仓库（Docker Hub / 私有仓库）。
    
3. 在服务器上拉取镜像。
    
4. 运行容器，映射端口、挂载卷。
    
5. 用户访问宿主机的端口，就能用容器内的服务。
    

---

✅ **一句话总结**：

- **镜像** = 模板
    
- **容器** = 镜像的运行实例
    
- **仓库** = 镜像的存放地
    
- **卷** = 数据持久化
    
- **网络** = 容器之间/容器与外界的通信方式
    


## 镜像&容器
#### 镜像是“一堆文件”

镜像是**一个只读的、分层的文件系统快照**。它包含了运行某个软件所需的所有**静态**文件：二进制程序、库文件、配置文件、环境依赖等。它就是一个打包好的模板，本身是死的，不会做任何事。

**可以把镜像想象成一套毛坯房的CAD设计图**。图纸详细规定了哪里是承重墙，哪里要走水管电线（定义了运行环境）。但它自己不会住人。

#### 容器是“一个进程”

**从宿主OS的角度来看，一个容器本质上就是一个（或一组）被隔离和限制了的进程。**
- 是**镜像的一个运行实例**。

Docker利用Linux内核的三大核心技术来实现这一点：

1. **Namespaces (命名空间)**： 它实现了**隔离**。它为这个进程提供了一个独立的视图，让它拥有自己的PID进程号、网络栈、文件系统挂载点、主机名等，仿佛自己在一个独立的操作系统里。
    
2. **Cgroups (控制组)**： 它实现了**资源限制**。它可以限制这个进程能使用多少CPU、多少内存、多少IO带宽，防止某个容器耗尽所有系统资源。
    
3. **Union File System (联合文件系统)**： 它实现了**镜像的分层和容器的可写层**。容器运行时，会在只读的镜像层之上，添加一个薄薄的可写层。所有修改都发生在这个可写层里，不会影响底下的镜像。
    

**继续用房子的比喻：**

- **`docker run` 命令**：就是根据CAD图纸（镜像）**盖房子**的过程。
    
- **容器**：就是**正在运行的房子**本身。房子里住了人（运行的进程），开了灯（消耗了CPU），用了水（消耗了内存）。
    
- **从宿主机看**：你用 `ps auxf` 命令，可以看到这个“房子”里的“人”（进程）就在宿主机的进程列表里，只不过它被“Namespaces”这堵墙关在了自己的房子里，看不到也干扰不到其他房子里的进程。



# 命令
[[命令#Docker]]

创建和运行容器命令：
```
docker run -d --name 容器名 -p 宿主机端口:容器端口 -v 宿主机目录：容器目录 镜像名:标签
```

#### 1. 端口映射 (`-p`)
端口映射 (`-p`)：让外部世界能访问容器内的服务

- **问题**：Docker 容器就像一台独立的小电脑，拥有自己的内部网络和 IP 地址。默认情况下，外部世界（包括你的服务器本身）是无法直接访问到容器内部运行的服务的（比如 MySQL 的 3306 端口）。
    
- **解决方案**：**端口映射**。它就像是在容器和服务器主机之间建立了一条**隧道**或**端口转发规则**。
    
- **命令格式**： `-p <宿主端口>:<容器端口>`
    
- **比喻**：
    
    - **容器端口**：公司内部的分机号（比如 MySQL 的分机号是 3306）。
        
    - **宿主端口**：公司的总机号码（比如你希望外界通过 3306 这个“总机号”转接到内部）。
        
    - `-p 3306:3306` 就意味着：**“将所有发送到服务器 3306 端口的请求，全部转发到容器的 3306 端口上去。”**

	
> [!NOTE] 宿主机的一个端口只能被一个容器或一个进程绑定
>  宿主机端口是唯一的，**不能同时映射给多个容器**。
>  如果要跑多个容器，换宿主机端口（如 `3307:3306`、`3308:3306`）。
>  如果容器只在 **内部网络** 使用，不需要对外暴露，可以不做 `-p` 映射，而是直接用 **Docker 网络 (bridge/network)** 通信。容器间可以直接通过 **容器名 + 端口** 访问，不依赖宿主机端口。避免宿主机端口冲突。


#### 2. 数据卷挂载 (`-v`)

数据卷挂载 (`-v`)：实现数据持久化

**挂载可以参考**：[[Linux#1.2 挂载]]

- **问题**：Docker 容器是** ephemeral （ ephemeral ）** 的。这意味着，一旦你删除容器，容器内创建的所有数据（包括 MySQL 的数据库文件）也会随之丢失。这显然是无法接受的。
    
- **解决方案**：**数据卷挂载**。它将容器内的某个目录（如 MySQL 的数据目录）**映射**到服务器主机上的一个目录。实际上只有一份数据，即宿主机那个目录里面的。
    
- **命令格式**： `-v <宿主目录>:<容器目录>`
    
- **好处**：
    
    1. **数据持久化**：即使容器被删除，数据也安全地保存在你的服务器上。下次启动新容器并挂载同一个目录，数据就恢复了。
        
    2. **方便管理**：你可以在服务器上直接备份、查看这些数据文件。
        
- **一个绝佳的比喻：**

	- 宿主机上的 `/host/data` 是一个**真实的物理房间**。
	    
	- 容器内的 `/container/data` 是这个房间**开在容器内部的“一扇门”**。
	    
	- 无论你是从宿主机直接进入房间，还是通过容器内部的这扇门进入房间，你进入的、操作的、存放东西的，都是**同一个物理空间**。
	    
	- **不存在两个房间，也不存在“同步”的过程。**

所以，不存在“主机发给容器”或“容器发给主机”，而是它们**访问的是同一块磁盘区域**。

> [!NOTE] 挂载目录的使用路径
> - **容器目录：必须是绝对路径**（比如 `/app/data`）。
> 	- 容器里有自己的文件系统，`/app`、`/data` 这种路径才有意义。
> 	- 写相对路径（比如 `./data`）在容器里根本无法解析，会报错。
> -  **宿主机目录：推荐用绝对路径**，虽然可以用相对路径，但相对路径是相对你执行 `docker run` 时的工作目录，容易搞混


### 3. 如果启动容器时没挂载，数据存放在哪里？

这是一个极其重要的问题，也是新手最容易栽跟头的地方。

如果运行容器时**没有**使用 `-v` 参数进行挂载，那么容器内进程产生的所有数据（比如 MySQL 的表数据、日志等）都会存储**在容器内部的一个临时的、匿名的可写层**里。

这个可写层是容器独有的，与镜像层是分开的。它的特点是：

**容器被删除 (`docker rm`)，这个可写层连同里面的所有数据都会被一并彻底删除，无法恢复。**

