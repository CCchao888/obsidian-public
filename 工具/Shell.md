2025-06-03 15:44
# 基本概念
shell 就是命令解释器，命令来源有两种：用户手动输入 & GUI转换而来
用户与计算机的交互无非两种方式，CLI 和 GUI。GUI的操作又分为两种情况，总共三种情况：
- GUI --- shell --- 系统调用
	- 比如ide点击运行python程序，本质是生成命令，开shell去执行 python ……
- CLI --- shell --- 系统调用
- GUI --- 系统调用
	- 有些GUI本身就是OS的一部分，会直接调用OS的API
## 环境变量
每一个进程都有初始环境/上下文，初始环境包含了环境变量（操作系统传递配置信息给进程的机制，启动进程时系统传入的上下文参数），shell控制了进程的初始环境，每一个shell都继承了用户/系统环境变量，但是可以修改这些初始环境/环境变量（仅限当前shell生效）。

环境变量是分层的，每一个子层都继承了父层（复制的快照，而不是引用共享）。所有用户态进程都是某个进程fork出来的（大多数是shell，还有桌面管理器、系统初始化进程等），这些进程都会继承其父进程的环境变量。

对于Windows系统，环境变量的继承是合并覆盖（环境变量是键值对，主要通过名字），主要三种情况，以系统变量和用户变量为例（==对于普通变量用户环境变量优先于系统环境变量，对于path变量系统环境变量优先于用户环境变量==）：
- 不同名变量，用户变量获得系统变量（用户变量没有）
	- 比如系统变量有A=a，用户变量没有，用户终端运行时会获得A=a
- 同名变量，用户变量会覆盖系统变量
	- 系统变量A=n、用户变量A=m，用户终端运行是A=m
- 特殊的列表变量Path，会合并拼接（path变量按顺序查询的，在前面的先匹配，而且这里的拼接并不会自动去重，是直接拼接）
	- 系统变量的Path=a;b;c    用户变量的Path=d;e;f   最终用户终端会获得 Path=a;b;c;d;e;f  ==合并拼接且系统变量在前面==
合并拼接获得的变量是内存中的环境快照不会写回系统或者用户变量

![[Pasted image 20250619153330.png]]




## 一些区分
CLI & GUI
- CLI 是命令行，以文字方式与计算机交互
- GUI 是图形用户界面，以图形、点击等进行交互
终端 & shell & bash 
- 终端：运行 shell 的图形界面程序
- shell：终端内部真正执行命令的程序，每次新开终端都新开了一个shell进程
- bash：shell的一种实现

有些软件需要配置环境变量path的原因：
- 图形软件不需要，命令行软件（python，git等）需要
- OS启动程序首先需要知道可执行文件（程序）的位置/绝对路径，图形软件一般都有桌面图标/快捷方式，它们直接指向可执行文件位置，而命令软件没有只能配置环境变量path，这样shell解释命令才能识别并找到可执行文件

## shell的执行流程
  shell 类似 python，是一个编程环境，有变量、循环、函数等等，在shell执行命令实际上是在**执行shell可以解释的代码**，如果命令不是 shell 的编程关键字，那么它会依赖环境变量 $PATH 去搜索程序/外部命令/文件。
### shell执行命令的核心步骤
1. 命令解析
	- 基于空格拆解命令
		- 第一个单词代表代表执行的程序
		- 后续单词是参数数组
	- 处理参数中的空格
		- 单引号、双引号、转义在空格前加 \
	- 处理特殊符号
		- ~ 扩展为用户命目录
		- * 为通配符扩展，如*.txt, 匹配 a.txt, b.txt
		- $VAR 变量替换
2. 判断命令类型
	- 内置命令：直接由shell 进程执行，如 cd, 
	- 外部程序：磁盘上的可执行文件，创建子进程去执行，如 ls, gcc, python
	- 别名：用户定义的快捷命令
	- 函数：shell脚本中定义的函数
3. 创建子进程（针对外部命令）
	- fork() 系统调用，创建shell进程的完整副本
	- 子进程执行命令，父进程等待子进程
4. 执行命令
	- 子进程加载目标程序
	- 系统调用，通过内核与硬件交互
5. 结果返回
	- 输出流控制
	- 父进程回收子进程

### shell 创建连接

#### 每个程序默认有三个核心数据流：

| **流类型**           | 文件描述符 | 默认设备 | 作用        |
| ----------------- | ----- | ---- | --------- |
| **标准输入 (stdin)**  | 0     | 键盘   | 程序读取数据的源头 |
| **标准输出 (stdout)** | 1     | 显示器  | 程序输出正常结果  |
| **标准错误 (stderr)** | 2     | 显示器  | 程序输出错误信息  |
#### 重定向操作符
```
# 1. 输出重定向（覆盖）
echo "hello" > hello.txt  # 将 stdout 写入文件（文件不存在则创建）

# 2. 输出重定向（追加）
echo "world" >> hello.txt # 追加到文件末尾

# 3. 输入重定向
cat < hello.txt          # 从文件读取 stdin

# 4. 错误重定向
ls /nonexist 2> error.log # 将 stderr 写入文件
```

#### 管道（Pipe）
`ls -l / | tail -n1`
- **`|` 的作用**：将前命令的 **stdout** 连接到后命令的 **stdin**
    
- **执行流程**：
    
    1. `ls -l /` 输出目录列表（几百行）
        
    2. 管道实时传输数据给 `tail`
        
    3. `tail -n1` 只取最后一行输出
        
    4. 最终屏幕显示：`drwxr-xr-x 1 root root 4096 Jun 20 2019 var`
### 文件描述符重定向
所有重定向和管道的底层都是 **操作文件描述符**：非负整数，代表进程打开的文件、管道、设备等资源，每个进程都有自己的文件描述符表。管道和重定向只是操作文件描述符的不同方式。
```
# 管道等价形式（理解用，实际不这样写）
ls -l / > tempfile  # 输出到临时文件
tail -n1 < tempfile # 从临时文件读取
rm tempfile

# 管道实际实现（内存操作，无磁盘IO）
ls -l / | tail -n1  # 内核通过pipe()创建内存管道
```


## shell 脚本
大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell 脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。

下面以最流行的 bash 为例：

Bash 中的字符串通过 `'` 和 `"` 分隔符来定义，但是它们的含义并不相同。以 `'` 定义的字符串为原义字符串，其中的变量不会被转义，而 `"` 定义的字符串会将变量值进行替换。
```
foo=bar
echo "$foo"
# 打印 bar
echo '$foo'
# 打印 $foo
```

## ssh
ssh 是 secure shell，用于操作远程设备。
- 远程登录、远程执行命令、文件传输
- 使用加密的 TCP 连接
- 基础命令-远程登录设备：`ssh 用户名@远程IP地址`

ssh 密钥认证，是比密码更安全的方式（免密登录）
- 生成密钥对
- 本地存私钥，私钥解密
- 远程设备存公钥，公钥加密

**远程开发**--使用 vs code 的 remote-ssh 插件连接远程服务器，在本地的 IDE 像操作本机一样开发远程项目。
- 开发体验和本地一样，但是远程服务器资源更好
- 开发环境统一，方便多人协作
- 连接之后，在本地编辑远程文件、运行远程的终端
