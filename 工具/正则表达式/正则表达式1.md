正则表达式（Regular Expression，简称 regex）是一个非常强大的工具，用于**文本的搜索、匹配和替换**。它就像一把文本处理的“瑞士军刀”，一旦掌握，你会发现在编程、文本编辑、数据处理等方面效率倍增。

别被它看起来像乱码的样子吓到，我们一步一步来学。

### 一、核心概念：元字符

正则表达式的核心是**元字符**，这些字符在正则中有特殊含义。我们先从最基础的开始。

#### 1. 匹配单个字符

| 元字符 | 含义 | 示例 | 匹配示例 |
| :--- | :--- | :--- | :--- |
| `.` | **匹配任意一个**字符（除换行符外） | `a.c` | `abc`, `a@c`, `a5c` |
| `\d` | 匹配一个**数字** (digit) | `\d\d` | `12`, `00`, `99` |
| `\w` | 匹配一个**单词字符**（字母、数字、下划线） | `\w\w\w` | `A_b`, `a1c`, `中文` (取决于引擎) |
| `\s` | 匹配一个**空白字符**（空格、制表符、换行符等） | `a\sb` | `a b` (中间有空格) |
| `[abc]` | 匹配**括号内**的任意一个字符 | `[aeiou]` | `a`, `e` (在 "hello" 中匹配 `e`, `o`) |
| `[^abc]` | 匹配**除了**括号内字符的任意一个字符 | `[^0-9]` | `a`, `@` (在 "a1" 中匹配 `a`) |
| `[a-z]` | 匹配一个**范围**内的字符 | `[A-Za-z]` | 任意一个大写或小写字母 |

**示例：**
- `gr[ae]y`：匹配 `gray` 或 `grey`。

#### 2. 匹配数量（量词）

量词用来指定**它前面的一个字符或组**出现的次数。

| 元字符 | 含义 | 示例 | 匹配示例 |
| :--- | :--- | :--- | :--- |
| `*` | 出现 **0次 或 多次** | `ab*c` | `ac`, `abc`, `abbc` |
| `+` | 出现 **1次 或 多次** | `ab+c` | `abc`, `abbc` (不能是 `ac`) |
| `?` | 出现 **0次 或 1次** | `colou?r` | `color`, `colour` |
| `{n}` | 出现**恰好 n 次** | `\d{4}` | `1234`, `2023` (4位数字) |
| `{n,}` | 出现**至少 n 次** | `\w{3,}` | `hello`, `abc123` |
| `{n,m}` | 出现 **n 到 m 次** | `\d{2,4}` | `12`, `123`, `1234` |

**示例：**
- `https?://`：匹配 `http://` 或 `https://`。

#### 3. 匹配位置

| 元字符 | 含义 | 示例 | 匹配示例 |
| :--- | :--- | :--- | :--- |
| `^` | 匹配**字符串的开始** | `^Hello` | `Hello World` 中的 `Hello` |
| `$` | 匹配**字符串的结束** | `world!$` | `Hello world!` 中的 `world!` |
| `\b` | 匹配一个**单词的边界** | `\bcat\b` | `a cat` 中的 `cat`，但不匹配 `category` |

**示例：**
- `^\d{4}$`：匹配一个正好是4位数字的字符串（如年份）。

---

### 二、实战演练：常用的正则表达式

现在我们把上面的元组合起来使用。

1.  **匹配邮箱地址**
    ```regex
    ^[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]{2,}$
    ```
    - `^[\w.-]+`：开头是1个或多个单词字符、点或连字符（用户名部分）。
    - `@`：一个直接的@符号。
    - `[a-zA-Z\d.-]+`：1个或多个字母、数字、点或连字符（域名部分）。
    - `\.`：一个真实的点（.），需要用反斜杠转义。
    - `[a-zA-Z]{2,}$`：以2个或更多字母结尾（如 com, cn, net）。

2.  **匹配URL**
    ```regex
    https?://[^\s/$.?#].[^\s]*
    ```
    - `https?://`：匹配 http:// 或 https://。
    - `[^\s/$.?#]+`：匹配除了空格、`/`, `$`, `.`, `?`, `#` 之外的任何字符（域名）。
    - `.[^\s]*`：匹配后续的任何非空字符（路径、参数等）。

3.  **匹配中文**
    ```regex
    [\u4e00-\u9fa5]
    ```
    - 这是Unicode编码范围，匹配绝大多数汉字。

4.  **提取JSON中的某个值**（例如提取 `"name"` 对应的值）
    ```regex
    "name":\s*"([^"]*)"
    ```
    - `"name":`：匹配固定的 `"name":` 部分。
    - `\s*`：匹配0个或多个空白字符（空格、换行等）。
    - `"([^"]*)"`：匹配双引号，并**捕获**括号内所有非双引号的内容。

---

### 三、高级技巧：分组与捕获

- `(abc)`：**捕获分组**。将括号内的内容作为一个整体，并记住匹配的文本，后续可以引用。
- `(?:abc)`：**非捕获分组**。只分组，不记住匹配的文本，性能更好。
- `|`：**或**操作。`a|b` 匹配 a 或 b。

**示例：**
- 匹配 `jpg`, `jpeg`, `png`, `gif` 图片后缀：
  ```regex
  \.(?:jpg|jpeg|png|gif)\b
  ```
  这里使用 `(?:...)` 非捕获分组，因为我们不需要记住具体是哪个后缀。

---

### 四、如何在编程中使用

光知道 pattern 还不够，关键是要在代码里用起来。以下是一些常见语言的示例：

**1. Java**
```java
import java.util.regex.*;

String text = "我的邮箱是 example@email.com，欢迎联系！";
String pattern = "[\\w.-]+@[a-zA-Z\\d.-]+\\.[a-zA-Z]{2,}";

Pattern p = Pattern.compile(pattern);
Matcher m = p.matcher(text);

while (m.find()) { // 查找所有匹配
    System.out.println("找到邮箱: " + m.group());
}
```

**2. JavaScript**
```javascript
const text = "我的邮箱是 example@email.com，欢迎联系！";
const pattern = /[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]{2,}/g;

const matches = text.match(pattern);
if (matches) {
    console.log("找到邮箱:", matches);
}

// 或者使用 test 方法检查是否存在
const isValid = pattern.test(text);
console.log("是否包含邮箱:", isValid);
```

**3. Python**
```python
import re

text = "我的邮箱是 example@email.com，欢迎联系！"
pattern = r'[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]{2,}'

matches = re.findall(pattern, text)
print("找到邮箱:", matches)

# 替换所有邮箱为 [EMAIL]
replaced_text = re.sub(pattern, '[EMAIL]', text)
print("替换后:", replaced_text)
```

---

### 五、工具推荐与练习

1.  **在线测试工具**：
    - **[RegExr](https://regexr.com/)** (强烈推荐！边写边测，有解释和备忘单)
    - **[Regex101](https://regex101.com/)** (功能强大，能生成代码)

2.  **练习平台**：
    - **[RegexOne](https://regexone.com/)** (交互式教程，像玩游戏一样学)
    - **[Regex Crossword](https://regexcrossword.com/)** (正则表达式填字游戏，非常烧脑有趣)

**最后给你的建议：**
- **不要死记硬背**：记住核心元字符，复杂的表达式随时查。
- **从小处着手**：先写一部分，测试一下，再慢慢添加和修改。
- **理解而非复制**：网上找的正则表达式，一定要用工具分解理解，不然很容易出错。


# 六、正则表达式中的分组：详解与使用指南

分组是正则表达式中非常强大且常用的功能，它允许你将一部分模式组合在一起，并对这个组进行各种操作。让我详细解释分组的用法。

## 什么是分组？

分组使用圆括号 `()` 来创建，它有两个主要作用：
1. 将多个字符视为一个整体单元
2. 捕获匹配的文本以供后续使用

## 分组的基本类型

### 1. 捕获分组 (Capturing Groups)

最基本的分组形式，会记住匹配的内容。

**语法：** `(pattern)`

**示例：**
```regex
(abc)+
```
- 匹配一个或多个连续的"abc"序列
- 会匹配 "abc"、"abcabc" 等
- 匹配的内容会被存储起来，可以通过反向引用或代码访问

### 2. 非捕获分组 (Non-capturing Groups)

只分组但不捕获匹配内容，性能稍好。

**语法：** `(?:pattern)`

**示例：**
```regex
(?:abc)+
```
- 匹配一个或多个连续的"abc"序列
- 但不会记住匹配的内容

### 3. 命名捕获分组 (Named Capturing Groups)

给分组命名，使代码更易读。

**语法：** `(?<name>pattern)` 或 `(?'name'pattern)`

**示例：**
```regex
(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})
```
- 匹配日期格式如 "2023-05-15"
- 可以通过名称 "year"、"month"、"day" 引用匹配的内容

## 分组的使用场景

### 1. 应用量词到字符组

```regex
(ab){2,3}
```
- 匹配 "abab" 或 "ababab"
- 如果没有分组，`ab{2,3}` 只会匹配 "abb" 或 "abbb"

### 2. 多选项组合

```regex
(apple|orange|banana) juice
```
- 匹配 "apple juice"、"orange juice" 或 "banana juice"

### 3. 提取数据（捕获）

```regex
Name: (\w+), Age: (\d+)
```
- 从 "Name: John, Age: 25" 中提取姓名和年龄
- 第一个分组捕获 "John"，第二个分组捕获 "25"

### 4. 反向引用 (Backreferences)

在同一个正则表达式中引用之前捕获的内容。

**语法：** `\数字`（数字表示分组的顺序）

**示例：**
```regex
(['"])(.*?)\1
```
- 匹配被相同引号包围的文本
- `\1` 引用第一个分组匹配的引号（单引号或双引号）
- 可以匹配 `'hello'` 或 `"world"`，但不匹配 `'hello"`

### 5. 在替换中使用分组

在许多编程语言中，可以在替换操作中使用分组捕获的内容。

**示例：**
将 "姓, 名" 格式改为 "名 姓" 格式：
```regex
(\w+), (\w+)
```
替换为：
```
$2 $1
```
- 输入："Doe, John" → 输出："John Doe"

## 实际代码示例

### JavaScript 中的分组使用

```javascript
// 提取日期组成部分
const datePattern = /(\d{4})-(\d{2})-(\d{2})/;
const dateStr = "2023-05-15";
const match = dateStr.match(datePattern);

console.log(match[0]); // "2023-05-15" (完整匹配)
console.log(match[1]); // "2023" (第一个分组)
console.log(match[2]); // "05" (第二个分组)
console.log(match[3]); // "15" (第三个分组)

// 使用命名分组 (ES2018+)
const namedPattern = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const namedMatch = dateStr.match(namedPattern);

console.log(namedMatch.groups.year); // "2023"
console.log(namedMatch.groups.month); // "05"
console.log(namedMatch.groups.day); // "15"

// 替换中使用分组
const nameStr = "Doe, John";
const swapped = nameStr.replace(/(\w+), (\w+)/, "$2 $1");
console.log(swapped); // "John Doe"
```

### Python 中的分组使用

```python
import re

# 提取数据
text = "Name: John, Age: 25"
pattern = r"Name: (\w+), Age: (\d+)"
match = re.search(pattern, text)

if match:
    print(match.group(0))  # "Name: John, Age: 25"
    print(match.group(1))  # "John"
    print(match.group(2))  # "25"

# 使用命名分组
pattern = r"Name: (?P<name>\w+), Age: (?P<age>\d+)"
match = re.search(pattern, text)

if match:
    print(match.group('name'))  # "John"
    print(match.group('age'))   # "25"

# 替换中使用分组
result = re.sub(r"(\w+), (\w+)", r"\2 \1", "Doe, John")
print(result)  # "John Doe"
```

### Java 中的分组使用

```java
import java.util.regex.*;

public class GroupExample {
    public static void main(String[] args) {
        String text = "Name: John, Age: 25";
        Pattern pattern = Pattern.compile("Name: (\\w+), Age: (\\d+)");
        Matcher matcher = pattern.matcher(text);
        
        if (matcher.find()) {
            System.out.println(matcher.group(0)); // "Name: John, Age: 25"
            System.out.println(matcher.group(1)); // "John"
            System.out.println(matcher.group(2)); // "25"
        }
        
        // 替换中使用分组
        String nameStr = "Doe, John";
        String result = nameStr.replaceAll("(\\w+), (\\w+)", "$2 $1");
        System.out.println(result); // "John Doe"
    }
}
```

## 分组的高级用法

### 1. 条件匹配

```regex
(abc)?def(?(1)xyz|uvw)
```
- 如果捕获组1匹配了内容，则匹配"xyz"
- 否则匹配"uvw"

### 2. 原子分组 (Atomic Groups)

防止回溯，提高性能。

**语法：** `(?>pattern)`

```regex
(?>a|ab)c
```
- 匹配 "ac" 但不匹配 "abc"
- 因为原子分组一旦匹配就不会回溯

## 注意事项

1. **性能考虑**：不必要的捕获分组会影响性能，如果不需捕获内容，使用非捕获分组 `(?:)`
2. **分组编号**：分组从左到右编号，从1开始
3. **嵌套分组**：分组可以嵌套，编号按左括号的顺序
4. **反向引用限制**：不同正则引擎对反向引用的支持可能不同

## 练习建议

1. 尝试编写匹配电子邮件的正则，并分别捕获用户名和域名部分
2. 编写匹配日期的正则，使用命名分组捕获年、月、日
3. 尝试使用反向引用匹配HTML标签（如 `<h1>标题</h1>`）

分组是正则表达式中非常强大的功能，掌握它们将极大提高你处理文本的能力。多练习，你会逐渐熟悉它们的各种用法！